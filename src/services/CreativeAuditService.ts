import { getFirestore, collection, addDoc, serverTimestamp, getDocs, query, orderBy, doc, setDoc, increment } from 'firebase/firestore';
import { callFunction } from './api';

export type CreativeActionType = 'INJECTION' | 'CURATION' | 'STRUCTURE' | 'RESEARCH';

export interface CreativeLogEntry {
    id?: string; // Auto-generated by Firestore
    timestamp?: any; // serverTimestamp
    projectId: string;
    userId: string; // Added for security context
    component: string;
    actionType: CreativeActionType;
    description: string;
    payload: Record<string, any>;
    sessionHash?: string;
}

/**
 * Creative Audit Service
 * "The Black Box" - Records strict legal evidence of human creative will.
 */
export const CreativeAuditService = {

    /**
     * Logs a creative event to the immutable audit trail.
     * Path: users/{userId}/projects/{projectId}/audit_log/{logId}
     */
    async logCreativeEvent(entry: Omit<CreativeLogEntry, 'id' | 'timestamp'>): Promise<string> {
        const db = getFirestore();
        const { projectId, userId } = entry;

        // üü¢ DEBUG: Legal Evidence Real-Time View
        if (import.meta.env.DEV) {
            console.log(`‚öñÔ∏è [AUDIT SIGNED] ${entry.actionType} in ${entry.component}:`, entry.description, entry.payload);
        }

        try {
            // Note: We use the nested 'users' collection to match firestore.rules security model.
            const logRef = collection(db, 'users', userId, 'projects', projectId, 'audit_log');

            const docRef = await addDoc(logRef, {
                ...entry,
                timestamp: serverTimestamp()
            });

            return docRef.id;
        } catch (error) {
            console.error("[CreativeAuditService] Failed to log event:", error);
            // We do not throw here to prevent blocking the user experience.
            // The audit is critical but should fail silently on the client side if network/auth issues occur,
            // or we could implement a local queue for retry. For now, just log error.
            return "";
        }
    },

    /**
     * Generates a legal audit report in plain text/markdown format.
     * Queries all logs for the project, sorts them, and creates a formatted string.
     */
    async generateAuditReport(projectId: string, userId: string, format: 'txt' | 'md' = 'txt'): Promise<string> {
        const db = getFirestore();
        try {
            const logRef = collection(db, 'users', userId, 'projects', projectId, 'audit_log');
            const q = query(logRef, orderBy('timestamp', 'asc'));

            const snapshot = await getDocs(q);
            const logs: CreativeLogEntry[] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as CreativeLogEntry));

            if (logs.length === 0) return "NO AUDIT RECORDS FOUND.";

            // METRICS
            const totalEvents = logs.length;
            const injections = logs.filter(l => l.actionType === 'INJECTION').length;
            const curations = logs.filter(l => l.actionType === 'CURATION').length;
            const structures = logs.filter(l => l.actionType === 'STRUCTURE').length;

            const isMd = format === 'md';
            let report = "";

            // HEADER
            if (isMd) {
                report += `# CERTIFICATE OF AUTHORSHIP\n`;
                report += `**Project ID:** ${projectId}\n`;
                report += `**Generated:** ${new Date().toISOString()}\n\n`;
            } else {
                report += `CERTIFICATE OF AUTHORSHIP\n`;
                report += `=========================\n`;
                report += `Project ID: ${projectId}\n`;
                report += `Generated: ${new Date().toISOString()}\n\n`;
            }

            // METRICS
            if (isMd) {
                report += `## METRICS\n`;
                report += `- **Total Creative Acts:** ${totalEvents}\n`;
                report += `- **Human Injections (Writing):** ${injections}\n`;
                report += `- **Curation Decisions (Selection):** ${curations}\n`;
                report += `- **Structural Changes (Arrangement):** ${structures}\n\n`;
            } else {
                report += `METRICS:\n`;
                report += `- Total Creative Acts: ${totalEvents}\n`;
                report += `- Human Injections (Writing): ${injections}\n`;
                report += `- Curation Decisions (Selection): ${curations}\n`;
                report += `- Structural Changes (Arrangement): ${structures}\n\n`;
            }

            // LOGS
            if (isMd) {
                report += `## AUDIT TRAIL (IMMUTABLE LOG)\n\n`;
            } else {
                report += `AUDIT TRAIL (IMMUTABLE LOG):\n`;
                report += `-----------------------------\n`;
            }

            logs.forEach(log => {
                const date = log.timestamp?.toDate ? log.timestamp.toDate().toISOString() : 'PENDING';

                if (isMd) {
                    report += `### [${date}] ${log.actionType}\n`;
                    report += `**${log.description}**\n`;
                    report += `- **Component:** ${log.component}\n`;
                    report += `- **ID:** \`${log.id}\`\n`;
                    if (log.payload && Object.keys(log.payload).length > 0) {
                        report += `- **Payload:** \`${JSON.stringify(log.payload)}\`\n`;
                    }
                    report += `\n`;
                } else {
                    report += `[${date}] [${log.actionType}] ${log.description}\n`;
                    report += `   > Component: ${log.component}\n`;
                    report += `   > ID: ${log.id}\n`;
                    if (log.payload && Object.keys(log.payload).length > 0) {
                        report += `   > Payload: ${JSON.stringify(log.payload)}\n`;
                    }
                    report += `\n`;
                }
            });

            if (isMd) {
                report += `\n---\n**[END OF RECORD]**\n`;
                report += `*Verified by Titanium Creative Audit Service.*`;
            } else {
                report += `\n[END OF RECORD]\n`;
                report += `Verified by Titanium Creative Audit Service.`;
            }

            return report;

        } catch (error) {
            console.error("Failed to generate report:", error);
            throw new Error("Failed to generate audit report.");
        }
    },

    /**
     * Calls the Cloud Function to generate a formal PDF Audit Certificate.
     */
    async fetchAuditPDF(projectId: string): Promise<string | null> {
        try {
            const data = await callFunction<any>('generateAuditPDF', { projectId });

            if (data.success && data.pdf) {
                return data.pdf; // Base64 string
            }
            return null;
        } catch (error) {
            console.error("Failed to fetch PDF:", error);
            return null; // Return null to handle UI error
        }
    },

    /**
     * Updates the persistent Human vs AI score counters for the project.
     * Path: users/{userId}/projects/{projectId}/stats/audit
     */
    async updateAuditStats(projectId: string, userId: string, humanChars: number, aiChars: number): Promise<void> {
        const db = getFirestore();
        try {
            const statsRef = doc(db, 'users', userId, 'projects', projectId, 'stats', 'audit');

            await setDoc(statsRef, {
                humanChars: increment(humanChars),
                aiChars: increment(aiChars),
                lastUpdated: serverTimestamp()
            }, { merge: true });

        } catch (error) {
            console.error("[CreativeAuditService] Failed to update stats:", error);
        }
    }
};
