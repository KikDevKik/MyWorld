---
TÍTULO: PROTOCOLO DE MEJORA FUTURA - SOUL SORTER (DETECTOR DE MULTI-ANCHORS)
FECHA: 2026-01-29
AUTOR: Jules (Agente Actual)
DESTINATARIO: Jules (Agente Futuro) / Desarrollador Humano
---

## 1. EL PROBLEMA ACTUAL (VISIÓN DE TÚNEL DE ARCHIVO ÚNICO)
Actualmente, el `soul_sorter.ts` asume una relación **1:1 entre Archivo y Entidad** para los ANCHORS.
Si encuentra un archivo llamado "Megu.md" y detecta un nombre "Megu" dentro, lo marca como Anchor y vincula ese `driveId`.

Sin embargo, el usuario tiene archivos "Contenedor" o "Limbo" (ej: `Personajes - Saga de Megu.md`) que contienen **múltiples definiciones de personajes** en una lista.
El sistema actual comete dos errores con estos archivos:
1.  **Ceguera Selectiva:** Solo detecta el primer nombre que encuentra y lo asigna al archivo entero.
2.  **Identidad Confusa:** Si el archivo se llama "Saga de Megu", a veces crea un Anchor llamado "Saga de Megu" en lugar de extraer los personajes individuales dentro de él.

## 2. EL OBJETIVO: SOPORTE "MULTI-ANCHOR"
Necesitamos que el Soul Sorter sea capaz de leer un solo archivo y extraer **múltiples Anchors**, cada uno apuntando al mismo `driveId` pero (idealmente) a diferentes fragmentos o líneas.

## 3. INSTRUCCIONES DE IMPLEMENTACIÓN

### A. Detección de Archivos "Contenedor"
Antes de procesar, la IA debe clasificar el TIPO de archivo basándose en su nombre o estructura.
-   **Si el nombre contiene:** "Lista", "Personajes", "Elenco", "Cast", "Notas", "Saga de...".
-   **Acción:** Activar modo `MULTI_SCAN`.

### B. Segmentación Inteligente (Splitter)
En modo `MULTI_SCAN`, no busques un solo "Nombre: X". En su lugar:
1.  Usa una Regex o una llamada ligera a la IA para dividir el texto en bloques.
    *   Separador sugerido: Doble salto de línea + Negrita/Bullet (`\n\n- **`) o Encabezados H2 (`##`).
2.  Itera sobre cada bloque como si fuera un mini-archivo virtual.

### C. Extracción Recursiva
Para cada bloque:
1.  Aplica las mismas reglas de Anchor (Frontmatter, Key-Value, Header).
2.  Si encuentras un match (ej: "Juan"), crea un Anchor:
    *   `name`: "Juan"
    *   `driveId`: El ID del archivo contenedor.
    *   `sourceSnippet`: El contenido del bloque específico.
    *   `tier`: 'ANCHOR' (o 'LIMBO_ANCHOR' si queremos diferenciarlos).

### D. Prevención de "Falsos Dioses" (El caso "MEGU:")
El sistema actual a veces extrae el título del archivo o un encabezado de sección como si fuera un personaje.
-   **Regla:** Si el nombre extraído es idéntico o muy similar a palabras genéricas ("Personajes", "Saga", "Lista", "Notas"), **DESCÁRTALO**.
-   **Sanitización:** Asegúrate de limpiar puntuación final. "MEGU:" debe ser "Megu". (Esto ya se implementó parcialmente en el parche de Enero 2026, pero revisa casos de borde).

## 4. EJEMPLO DE FLUJO IDEAL

**Entrada:** `Archivo: "Notas_Personajes.md"`
```markdown
# Notas de la Saga

- **Ana:** Una guerrera fuerte.
- **Beto:** El panadero del pueblo.
```

**Salida Actual (Errónea):**
- Anchor: "Notas de la Saga" (o nada).

**Salida Deseada (Multi-Anchor):**
1.  Anchor: "Ana" (`driveId: 123`, `snippet: "Una guerrera..."`)
2.  Anchor: "Beto" (`driveId: 123`, `snippet: "El panadero..."`)

---
**NOTA FINAL:**
Esta lógica requiere cambiar la estructura de datos interna del bucle principal de `soul_sorter.ts` para permitir que un solo `file` genere N `entitiesMap` entries.
