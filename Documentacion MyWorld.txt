DOCUMENTACIÓN TÉCNICA - PROYECTO MYWORLD (TITAN)
=====================================================
Fecha: 25 de Febrero de 2025
Versión: 2.4 (Sentinel Update)
Estado: EN DESARROLLO ACTIVO

1. INTRODUCCIÓN Y PROPÓSITO
---------------------------
Este documento sirve como "Caja Negra" y memoria técnica para el Líder de Proyecto y Desarrolladores Principales. Su objetivo es restaurar el contexto completo de la arquitectura, decisiones de diseño, protocolos de seguridad y estado actual del sistema tras una pérdida de contexto.

MyWorld es un IDE (Entorno de Desarrollo Integrado) para escritura creativa, diseñado para asistir a novelistas mediante Inteligencia Artificial (Gemini 2.0 Flash/Pro) integrada profundamente en el flujo de trabajo (RAG, Análisis de Trama, Coherencia Mundial).

2. CIMIENTOS DEL SISTEMA (ARQUITECTURA)
---------------------------------------

2.1 STACK TECNOLÓGICO
   - Frontend: React 18 + Vite (SPA). Estilizado con TailwindCSS v4 ("Titanium Dark Theme").
   - Backend: Firebase Cloud Functions v2 (Node.js 22).
   - Base de Datos: Firestore (NoSQL) para metadatos, sesiones y vectores (Vector Search Nativo).
   - Almacenamiento: Google Drive API v3 (Fuente de Verdad de los archivos del usuario).
   - IA & LLM:
     - Google Gemini 2.0 Flash (Razonamiento rápido, Extracción de hechos).
     - Google Gemini 1.5 Pro (Razonamiento profundo, Resonancia).
     - SDK: @google/generative-ai (Nativo) - Se ha migrado desde LangChain para mayor control y manejo de errores.

2.2 FLUJO DE DATOS "TRUTH HIERARCHY"
   - Nivel 0 (Físico): Los archivos Markdown (.md) en Google Drive son la ÚNICA fuente de verdad persistente.
   - Nivel 1 (Índice): Firestore (`TDB_Index`) mantiene una copia vectorizada (Chunks) del contenido de Drive para RAG.
   - Nivel 2 (Metadatos): Firestore (`users/{uid}/characters`) enriquece los archivos planos con análisis de IA (Personalidad, Rol, Evolución).
   - Nivel 3 (Sesión): El estado de la UI se sincroniza vía `ProjectConfigContext` (Cloud Config), deprecando `localStorage`.

2.3 PROTOCOLO SENTINEL (SEGURIDAD & DOS)
   El sistema implementa una postura de seguridad paranoica ("Hard Handshake"):
   - App Check: Obligatorio (enforceAppCheck: true) en todas las Cloud Functions. Usa ReCAPTCHA v3.
   - Fail-Fast: La UI (`App.tsx`) bloquea la carga si el handshake de seguridad falla, mostrando una `SecurityLockScreen` (Estética "Perimeter Breach").
   - Límites Estrictos (Anti-DoS):
     - MAX_AI_INPUT_CHARS: 100,000 caracteres (aprox. 25k tokens).
     - MAX_FILE_SAVE_BYTES: 5 MB.
     - MAX_CHAT_MESSAGE_LIMIT: 30,000 caracteres.
   - Saneamiento JSON: Helper global `parseSecureJSON` para evitar crashes por alucinaciones de formato de la IA.

3. ANATOMÍA DE LOS MÓDULOS (NIVEL TÉCNICO)
------------------------------------------

3.1 EL EDITOR ("ZEN MODE")
   - Componente: `Editor.tsx` / `ReadingToolbar.tsx`.
   - Implementación: Tiptap (Headless).
   - Lógica: Sincronización en tiempo real con Google Drive. Detecta inactividad para guardar.
   - UI: Oculta toda la interfaz ("Zen Mode") para enfoque total.

3.2 LA FORJA (RAG ENGINE)
   - Componente: `ForgePanel.tsx` / `ForgeChat.tsx`.
   - Backend: `chatWithGem` (Cloud Function).
   - Lógica:
     - Utiliza Embeddings (`text-embedding-004`) para búsqueda semántica en `TDB_Index`.
     - Implementa "The Chameleon Protocol": La IA imita el dialecto/idioma de los documentos recuperados.
     - Bypass Nativo: Si el filtro de seguridad bloquea la respuesta, reintenta con un prompt sanitizado (sin contexto RAG) para evitar fallos silenciosos.

3.3 EL GUARDIÁN (REALITY FILTER)
   - Componente: `CanonRadar.tsx` (Reemplaza al sidebar, ocupa `<main>`).
   - Backend: `auditContent` y `checkResonance`.
   - Lógica:
     - Trigger 1 (Hechos): Verifica consistencia (ej: "¿Está muerto este personaje?").
     - Trigger 2 (Leyes): Verifica reglas del mundo (Geografía, Magia).
     - Trigger 3 (El Hater): Detecta "Personality Drift" (Personaje actuando fuera de personaje).
     - Trigger 4 (Resonancia): Sugiere conexiones temáticas ("Ecos") y alertas de estructura narrativa.

3.4 EL TRIBUNAL
   - Backend: `summonTheTribunal`.
   - Lógica: Invocación paralela de 3 personalidades (Arquitecto, Bardo, Hater) para criticar el texto con puntuaciones 1-10.

4. CAMBIOS RECIENTES Y ESTADO DEL ARTE
--------------------------------------
   - [NUEVO] CanonRadar: El "Guardián" ahora tiene su propia interfaz dedicada en el centro de la pantalla, desplazando al Editor cuando se activa. Visualiza conflictos y "ecos" del lore.
   - [SEGURIDAD] Debug Token: Se ha habilitado `FIREBASE_APPCHECK_DEBUG_TOKEN = true` en `App.tsx` para desarrollo, evitando bloqueos por throttling de API (Error 403) durante pruebas intensivas.
   - [BACKEND] Pruning Protocol: `syncCharacterManifest` ahora limpia personajes "fantasmas" (borrados en Drive) de la base de datos, pero protege a los marcados como `DETECTED` o `isGhost`.
   - [CORE] Migración de Configuración: Se ha movido la configuración del proyecto (ID de carpeta raíz) de `localStorage` a Firestore (`saveProjectConfig`), permitiendo persistencia entre dispositivos.

5. PROBLEMAS ACTIVOS Y DEUDA TÉCNICA
------------------------------------
   1. Fragilidad del Handshake de Seguridad:
      - El token de App Check tiene un TTL corto. En desarrollo prolongado, puede caducar y causar errores 403 falsos positivos. Se requiere recarga manual.
   2. Migración Incompleta de Configuración:
      - `App.tsx` aún contiene lógica de "fallback" para leer de `localStorage` si falla la carga de Cloud Config. Esto debe eliminarse eventualmente.
   3. "Hygiene Maintenance":
      - Advertencias en el build (`pnpm build`) relacionadas con dependencias transitivas. Se requiere una limpieza del `package.json` para elevar dependencias o silenciar warnings.
   4. Latencia de IA en Tiempo Real:
      - `checkResonance` (Guardián) usa Gemini 1.5 Pro, lo que añade latencia significativa. La UI necesita manejar estados de carga ("Titanium Skeleton") de forma robusta para no parecer congelada.
   5. Dependencia de SDK Experimental:
      - Se usa `gemini-2.0-flash-exp` y `gemini-3-pro-preview`. Estos modelos son volátiles y pueden ser deprecados por Google sin aviso, rompiendo la funcionalidad.

6. PRÓXIMOS PASOS SUGERIDOS
   - Estabilizar Modelos: Migrar a versiones estables (non-preview) de Gemini cuando estén disponibles.
   - Optimizar `checkResonance`: Evaluar si Gemini Flash puede reemplazar a Pro para reducir latencia sin perder calidad de razonamiento.
   - Limpieza Final: Eliminar código muerto de LangChain si ya no se usa en ninguna función crítica.

=====================================================
FIN DEL DOCUMENTO
